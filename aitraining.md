# План еволюції AI: від Basic RAG до Enterprise-підходів (2026)

Покроковий план і чекліст на основі поточного стану проєкту та практик Enterprise.

---

## Поточний стан (V1 — Basic RAG)

- Контекст для AI: **останні N закритих тікетів** (`getSimilarResolvedTickets`), без семантики.
- Один промпт (INTENT_ANALYSIS тощо), один «шар» AI.
- Джерела знань: закриті тікети + база знань (KB) з семантичним пошуком (embeddings вже додано для KB).
- Немає самоперевірки (self-correction) та агентських циклів.

---

## Етап 1. Семантичний пошук по тікетах (апгрейд контексту)

**Мета:** Замість «останні 5 тікетів» підставляти в контекст тікети, **схожі за змістом** на запит користувача.

### Чекліст Етап 1

- [x] **1.1** Визначити джерело векторів для тікетів: окрема колекція `ticket_embeddings` (articleId → ticketId, embedding) або поле `embedding` у моделі Ticket (як у KnowledgeBase). — **Поле `embedding` у моделі Ticket.**
- [x] **1.2** Визначити текст для індексації тікета: напр. `title + description + resolutionSummary` (обрізаний), або окреме поле `searchableSummary`. — **`getIndexableTextForTicket`: title + description + resolutionSummary, обріз 8000.**
- [x] **1.3** Додати в `kbEmbeddingService` (або новий `ticketEmbeddingService`) функції: `indexTicket(ticket)`, `findSimilarTickets(query, options)` — аналогічно до статей KB. — **`ticketEmbeddingService.js`.**
- [x] **1.4** Замінити в `aiFirstLineService.getSimilarResolvedTickets(limit)` логіку: замість `.sort({ resolvedAt: -1 }).limit(limit)` викликати семантичний пошук по тікетах (вектор запиту = поточне повідомлення користувача з діалогу); повертати текст знайдених тікетів для контексту. — **При наявності `query` — `findSimilarTickets`, інакше fallback за датою.**
- [x] **1.5** Тригери індексації тікета: при закритті/вирішенні тікета (коли з’являється `resolutionSummary`) викликати індексацію; опційно — при створенні/оновленні. — **routes/tickets.js (PUT), ticketController.updateTicket, botConversationService.setResolutionSummary.**
- [x] **1.6** Скрипт первинної індексації існуючих закритих тікетів (аналог `indexKbEmbeddings.js`). — **`scripts/indexTicketEmbeddings.js`, npm `tickets:index`.**
- [x] **1.7** Fallback: якщо векторний пошук по тікетах недоступний або порожній — зберегти поточну логіку (останні N тікетів за датою). — **Реалізовано в `getSimilarResolvedTickets`.**

**Результат:** Контекст для AI стає релевантним за змістом, а не лише за часом.

---

## Етап 2. Двоетапний промпт і Self-Correction

**Мета:** AI спочатку оцінює, чи достатньо контексту; уникати «плутанини» від нерелевантних тікетів.

### Чекліст Етап 2

- [x] **2.1** Ввести промпт «критика» або крок перевірки: після отримання `similarTickets` (або similar + user message) один виклик AI: _«Чи ці приклади тікетів релевантні до запиту користувача? Так/Ні, коротко чому.»_ — **Промпт `SIMILAR_TICKETS_RELEVANCE_CHECK`, функція `checkSimilarTicketsRelevance()` в aiFirstLineService.**
- [x] **2.2** Якщо AI відповідає «Ні» або низька впевненість — не підставляти тікети в основний промпт INTENT_ANALYSIS (або підставляти порожній блок), щоб модель не плуталась. — **При «Ні» в контекст підставляється `(немає)`; те саме в getTicketSummary.**
- [x] **2.3** Опційно: логувати випадки, коли контекст відкинуто, для аналізу якості семантичного пошуку. — **logger.info('AI: similar tickets context rejected (self-correction)', { reason }).**

**Результат:** Менше галюцинацій через нерелевантний контекст.

---

## Етап 2б. Аналіз відгуків після закриття тікета (оцінки)

**Мета:** Використовувати оцінки (1–5) та опційний текстовий відгук після закриття тікета, щоб покращити якість контексту для AI та виявити проблемні кейси.

У проєкті вже є: поле `rating` і `feedback` у моделі Ticket, кнопки оцінки в Telegram після закриття (`rate_ticket_<id>_<1-5>`), збереження через `handleRateTicketCallback`.

### Чекліст Етап 2б

- [x] **2б.1** Збирати та зберігати оцінки надійно: переконатися, що після `handleRateTicketCallback` у тікет записуються `rating` (1–5) і опційно `feedback` (текст відгуку), щоб вони потрапляли в БД і не губились. — **API POST `/tickets/:id/rate` зберігає rating + feedback; Telegram: після оцінки запрошуємо текст відгуку, `handleTicketFeedbackMessage` зберігає в `qualityRating.feedback`.**
- [x] **2б.2** Фільтрація контексту за оцінками: у `getSimilarResolvedTickets` (або в семантичному пошуку по тікетах на Етапі 1) **включати в контекст лише тікети з оцінкою ≥ 4** (або з порогом з конфігу). Тікети без оцінки вважати нейтральними (включати) або виключити — вирішити політикою. — **`ticketEmbeddingService.findSimilarTickets`: фільтр «без оцінки або rating ≥ 4»; fallback у `getSimilarResolvedTickets` — той самий фільтр у Mongo.**
- [x] **2б.3** Вагування за оцінкою: при семантичному пошуку по тікетах множити score на вагу за рейтингом (напр. 5 → 1.2, 4 → 1.0, 3 → 0.8, 1–2 → 0.5 або виключати), щоб «добрі» тікети піднімались вище в контексті. — **`RATING_WEIGHT` у ticketEmbeddingService: 5→1.2, 4→1.0, 3→0.8, 1–2→0.5; score множиться на вагу перед сортуванням.**
- [x] **2б.4** Аналітика для адміна: сторінка або API-звіт «Якість за оцінками»: середня оцінка по часу, по категоріях, тікети з оцінкою 1–2 (для ручного розбору). Опційно — експорт тікетів з низькою оцінкою для покращення KB або процесів. — **GET `/api/analytics/quality-ratings` (startDate, endDate): averageRating, countByRating, byCategory, lowRatedTickets (до 100).**
- [x] **2б.5** Використання текстового `feedback`: якщо користувач залишив текст відгуку — зберігати його в тікеті; періодично (або вручну) аналізувати негативні відгуки: витягувати ключові скарги (ключові слова або простий AI-саммарі) для покращення статей KB або промптів. — **feedback зберігається (API + Telegram); низькооцінені тікети з feedback повертаються в `quality-ratings` для ручного аналізу.**
- [x] **2б.6** Опційно: автоматичне зниження ваги або виключення з RAG тікетів з оцінкою 1–2, щоб AI не орієнтувався на «невдалі» рішення. — **Тікети 1–2 виключені з контексту (2б.2) і мають вагу 0.5 у пошуку перед фільтром.**

**Результат:** Контекст для AI орієнтується на перевірені користувачами «хороші» кейси; низькі оцінки використовуються для аналітики та покращення системи.

---

## Етап 3. Agentic RAG (агентський цикл)

**Мета:** Якщо контексту недостатньо, AI може «попросити» додаткові кроки пошуку (наприклад, пошук по KB, по тікетах, по документації).

### Чекліст Етап 3

- [x] **3.1** Визначити набір «інструментів» агента: пошук по KB, по тікетах, (майбутнє: Confluence, файли). — **Інструменти: kb, tickets.**
- [x] **3.2** Реалізувати цикл: (1) перший виклик AI з поточним контекстом; (2) якщо модель повертає «потрібно більше інформації» + тип джерела — виконати відповідний пошук і додати результат у контекст; (3) повторний виклик AI з розширеним контекстом (обмежити кількість ітерацій, напр. 2). — **Цикл у analyzeIntent, fetchExtraContextForAgentic, до 2 ітерацій.**
- [x] **3.3** У промпті явно описати, коли і як AI може запитувати додатковий контекст (структурована відповідь: needMoreContext, source: "kb" | "tickets" | "none"). — **Секція AGENTIC RAG у INTENT_ANALYSIS.**
- [x] **3.4** Обмеження: не більше N додаткових пошуків за один запит, таймаут, щоб уникнути нескінченного циклу. — **MAX_AGENTIC_ITERATIONS = 2.**

**Результат:** Система сама вирішує, чи достатньо даних, і при потребі «ходить» по джерелах.

---

## Етап 4. Мультиагентна оркестрація (опційно, Enterprise)

**Мета:** Розділити ролі: пошук, перевірка, формулювання відповіді.

### Чекліст Етап 4

- [ ] **4.1** Визначити архітектуру: агент-пошуковець (retrieval), агент-критик (перевірка релевантності/галюцинацій), агент-редактор (фінальна відповідь).
- [ ] **4.2** Обрати інструмент оркестрації: LangGraph / CrewAI / AutoGen або власний пайплайн у Node.js (послідовні виклики з чіткими входами/виходами).
- [ ] **4.3** Реалізувати пошуковця: вхід — запит; вихід — відранжований список документів/фрагментів.
- [ ] **4.4** Реалізувати критика: вхід — запит + знайдені фрагменти; вихід — «ок» або «недостатньо» + рекомендація.
- [ ] **4.5** Реалізувати редактора: вхід — запит + перевірений контекст; вихід — фінальний текст відповіді.
- [ ] **4.6** Інтегрувати пайплайн у поточний flow (telegramAIService / aiFirstLineService).

**Результат:** Чіткий поділ відповідальності, легше налагоджувати та покращувати кожен крок окремо.

---

## Етап 5. Гібридний пошук (Long Context + RAG)

**Мета:** Комбінувати RAG (відбір топ-K документів) з великим контекстним вікном моделі.

### Чекліст Етап 5

- [ ] **5.1** Підняти ліміт кандидатів з RAG: напр. топ-20 або топ-100 документів (тікети + статті KB) замість 5.
- [ ] **5.2** Перевірити ліміт токенів моделі (OpenAI/Gemini) і розмір контексту; обрізати сумарний текст контексту під ліміт (наприклад, 100–200K токенів).
- [ ] **5.3** У системному промпті явно структурувати блок «Довгий контекст»: список документів з номерами, щоб модель могла посилатися на них.
- [ ] **5.4** Опційно: Hybrid Search — комбінувати векторний пошук і ключові слова (BM25 або $text) для фільтрації, потім ранжування за score.

**Результат:** Модель бачить більше релевантного контексту одночасно, точність зростає.

---

## Етап 6. Безпека та Privacy (LLMOps / On-premise)

**Мета:** Для чутливих даних — обробка без відправки в публічні API.

### Чекліст Етап 6

- [ ] **6.1** Оцінити вимоги: чи потрібно обробляти тікети/діалоги лише локально (банк, медицина, внутрішні політики).
- [ ] **6.2** Дослідити розгортання Small Language Model (SLM): Llama 3.x, Mistral тощо — локально або в приватній хмарі.
- [ ] **6.3** Визначити, які запити йдуть в публічний API (OpenAI/Gemini), а які — в локальну модель (наприклад, аналіз конфіденційних тікетів).
- [ ] **6.4** Реалізувати вибір провайдера за типом запиту або за налаштуванням (прапорець «використовувати лише локальну модель»).
- [ ] **6.5** Документувати політики зберігання та передачі даних для відповідності (GDPR, внутрішні аудити).

**Результат:** Контроль над даними, відповідність вимогам безпеки.

---

## Порівняльна таблиця

| Параметр                | Зараз (V1)          | Після Етап 1–2                   | Enterprise (Етап 3–6)                      |
| ----------------------- | ------------------- | -------------------------------- | ------------------------------------------ |
| Вибір контексту тікетів | Останні N за датою  | Семантичний пошук                | RAG + агентський цикл                      |
| Перевірка релевантності | Немає               | Двоетапний промпт                | Агент-критик / Self-Correction             |
| Джерела знань           | Тікети + KB         | Тікети + KB                      | + Confluence, Slack, PDF тощо              |
| Автономність            | Один відповідь      | —                                | Дії (наприклад, Jira)                      |
| Контекст                | Фіксований обсяг    | Релевантний набір                | Long Context + RAG                         |
| Відгуки після закриття  | Не використовуються | Фільтр/вага за оцінкою (Етап 2б) | Аналіз feedback для покращення KB/промптів |
| Privacy                 | Публічний API       | Публічний API                    | Опція On-premise SLM                       |

---

## Рекомендований порядок внедрення

1. **Етап 1** — семантичний пошук по тікетах: найбільший ефект при розумній складності, узгоджується з уже наявним RAG по KB.
2. **Етап 2** — двоетапний промпт / перевірка релевантності: невелика зміна промптів, зниження галюцинацій.
3. **Етап 2б** — аналіз відгуків після закриття: використання оцінок (1–5) і тексту відгуку для фільтрації/вагування контексту та аналітики якості.
4. Далі за потреби: **Етап 3** (Agentic), **Етап 5** (Long Context), **Етап 4** (Multi-agent), **Етап 6** (On-premise).

---

## Файли та місця в проєкті

| Що змінювати               | Файл / місце                                                                                                                         |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| Контекст з тікетів         | `aiFirstLineService.js` — `getSimilarResolvedTickets`                                                                                |
| Модель тікета / embeddings | `models/Ticket.js`, новий сервіс або `kbEmbeddingService.js` (розширення)                                                            |
| Промпти                    | `prompts/aiFirstLinePrompts.js`                                                                                                      |
| Агентський цикл            | Новий модуль або розширення `aiFirstLineService.js`                                                                                  |
| Індексація тікетів         | Тригери при закритті тікета, скрипт первинної індексації                                                                             |
| Оцінки та відгуки тікетів  | `models/Ticket.js` (rating, feedback), `telegramTicketService.handleRateTicketCallback`, звіти/фільтри в `getSimilarResolvedTickets` |

---

_Документ можна оновлювати по мірі виконання пунктів (знімати галочки з чеклісту)._
