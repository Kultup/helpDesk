# План логіки бота: класифікація запиту та семантичний пошук по базі знань

Покроковий checklist для реалізації.

---

## Частина A. Класифікація: питання vs звернення

### A.1 Підготовка

- [x] Визначити місце в потоці: після спеціальних запитів (погода, курс, команди), перед пошуком по KB у `analyzeIntent`
- [x] Вирішити варіант: розширити INTENT_ANALYSIS (Варіант 1) чи окремий промпт класифікації (Варіант 2)

### A.2 Реалізація класифікації

- [x] Додати в промпт INTENT_ANALYSIS (або створити окремий промпт) поле `requestType: "question" | "appeal"`
- [x] Додати в JSON-схему відповіді поле `requestType` та опційно `confidence` і коротке обґрунтування
- [x] У `analyzeIntent` (aiFirstLineService.js) повертати поле `requestType`
- [x] У `handleMessageInAiMode` (telegramAIService.js) використовувати `requestType` для вибору: спочатку KB (question) чи одразу збір даних для заявки (appeal)

### A.3 Правила після класифікації

- [x] **question:** пріоритет — семантичний пошук по KB; при високій релевантності — стаття; при середній — "Можливо, ви мали на увазі: …"; при низькій — LLM або запрошення заявки (пріоритет KB і кнопка «Створити тікет» вже в потоці; середня/низька релевантність — у частині B)
- [x] **appeal:** основний потік — збір деталей і створення заявки; опційно — семантичний пошук по KB як підказки (додано підказку 1 статті з KB після першого питання збору)

---

## Частина B. Семантичний пошук по базі знань

### B.1 Підготовка стеку

- [ ] Підтвердити використання OpenAI Embeddings (`text-embedding-3-small` або `ada-002`) — OpenAI вже в проєкті
- [ ] Визначити векторне сховище: MongoDB Atlas Vector Search чи MongoDB з полем `embedding` + косинусна схожість у Node.js

### B.2 Модель даних

- [ ] У моделі KnowledgeBase (backend/models/KnowledgeBase.js) додати поле `embedding: [Number]`
- [ ] Або створити окрему колекцію `kb_embeddings` з `articleId` + `embedding` (якщо обрано цей варіант)

### B.3 Новий сервіс embeddings

- [ ] Створити сервіс `backend/services/kbEmbeddingService.js` (або `kbVectorService.js`)
- [ ] Реалізувати `getEmbedding(text)` — виклик OpenAI embeddings
- [ ] Реалізувати `indexArticle(article)` / `reindexArticle(articleId)` — текст → вектор → збереження
- [ ] Реалізувати `findSimilarArticles(query, options)` — вектор запиту, векторний пошук, повернути `{ article, score }[]`

### B.4 Індексація бази знань

- [ ] Визначити текст для індексації: наприклад `title + " " + content.slice(0, 500)` або поле `searchableSummary`
- [ ] Написати скрипт первинної індексації для існуючих опублікованих статей
- [ ] Запустити скрипт і перевірити заповнення полів `embedding`
- [ ] Якщо MongoDB Atlas: створити Atlas Vector Search index для поля `embedding`

### B.5 Векторний пошук

- [ ] Реалізувати пошук: Atlas Vector Search або завантаження статей з `embedding` + косинусна схожість у Node.js
- [ ] Винести пороги score у конфіг/AISettings (наприклад високий 0.8, середній 0.5)
- [ ] У kbSearchService.js додати метод `findBestMatchForBotSemantic(query)` (або вбудувати в `findBestMatchForBot`)
- [ ] Логіка: спочатку семантичний пошук; якщо найкращий score вище порогу — повернути статтю; інакше fallback на $text + regex

### B.6 Тригери реіндексації

- [ ] При створенні статті викликати індексацію (routes/knowledgeBase.js або відповідний сервіс)
- [ ] При оновленні статті викликати реіндексацію
- [ ] При публікації статті переконатися, що вектор оновлений

---

## Частина C. Інтеграція в analyzeIntent і бот

### C.1 Блок KNOWLEDGE BASE SEARCH

- [ ] У aiFirstLineService.js у блоці KNOWLEDGE BASE SEARCH викликати семантичний пошук
- [ ] Враховувати результат класифікації: для `question` — пріоритет семантичному пошуку; для `appeal` — опційно підказки з KB
- [ ] При високому score — повертати одну найрелевантнішу статтю (як зараз з `kbArticle`)
- [ ] При середньому score — повертати список кандидатів для повідомлення "Можливо, ви мали на увазі: …" з кнопками/посиланнями
- [ ] При низькому score — не вважати знахідкою; fallback на $text + regex, далі LLM або запрошення заявки
- [ ] Зберегти fallback на поточний $text + regex при помилці embeddings або порожній векторній базі

### C.2 Telegram-бот

- [ ] У handleMessageInAiMode для типу `appeal` опційно запускати семантичний пошук і показувати 1–2 статті як підказки ("Можливо, вам допоможе: …")

---

## Частина D. Тестування

- [ ] **Питання + помилки:** запит з опечаткою (наприклад "ринтер") → знаходиться стаття про принтер
- [ ] **Питання + синоніми:** "ноутбук" / "комп'ютер" → релевантні статті
- [ ] **Звернення:** створення заявки без плутанини з відповіддю з KB
- [ ] **Fallback:** при вимкненому embeddings або порожній векторній базі працює $text + regex
- [ ] **Пороги:** перевірити поведінку при високому / середньому / низькому score

---

## Порядок кроків (флоу)

```
Текстове повідомлення
    → Класифікація (питання / звернення)
    → [question або невизначено] Семантичний пошук по KB (TOP-K)
        → score високий → Відповідь зі статті
        → score середній → "Можливо, ви мали на увазі: …"
        → score низький → Fallback $text + regex, далі LLM / заявка
    → [appeal] Збір деталей / створення заявки (опційно підказки з KB)
```

Спеціальні запити (погода, курс, команди) залишаються на початку обробки.

---

## Файли для змін

| Файл                                     | Дії                                                        |
| ---------------------------------------- | ---------------------------------------------------------- |
| `backend/prompts/aiFirstLinePrompts.js`  | INTENT_ANALYSIS: додати requestType                        |
| `backend/services/aiFirstLineService.js` | Класифікація, виклик семантичного пошуку, пороги score     |
| `backend/services/telegramAIService.js`  | Використання requestType, сценарії question/appeal         |
| `backend/services/kbSearchService.js`    | findBestMatchForBotSemantic або зміна findBestMatchForBot  |
| `backend/services/kbEmbeddingService.js` | **Новий:** getEmbedding, indexArticle, findSimilarArticles |
| `backend/models/KnowledgeBase.js`        | Поле embedding                                             |
| `backend/routes/knowledgeBase.js`        | Тригери індексації при створенні/оновленні                 |
| Скрипт індексації                        | **Новий:** первинна індексація існуючих статей             |
