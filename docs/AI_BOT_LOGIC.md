# Використання AI в Telegram-боті HelpDesk

## Ідея

Користувач описує проблему **вільним текстом**. Бот за допомогою AI веде короткий діалог (одне питання за раз), збирає необхідні дані і в кінці пропонує **готовий тікет** для підтвердження. Без класичного покрокового «крок 1 — заголовок, крок 2 — опис».

---

## Контекст користувача (важливо для AI)

Бот **вже знає дані зареєстрованого користувача** з профілю: місто, посада, заклад (institution), ПІБ, email тощо. Ці дані **не потрібно запитувати** в діалозі.

- **Місто** — відоме з профілю. Питання типу «В якому місті?» не ставимо.
- **Посада** — відома. Питання про посаду не актуальне.
- **Заклад (institution)** — якщо в профілі є прив’язка до закладу, AI має це знати і використовувати в описі тікета.

**Що передавати в кожен виклик AI:** об’єкт контексту користувача, наприклад:

- `userCity` — назва міста
- `userPosition` — назва посади
- `userInstitution` — назва закладу (якщо є)
- за бажанням: `userName`, `userEmail` (для логів або підпису в описі)

AI використовує цей контекст, щоб:
- **не ставити** зайвих питань про місто, посаду чи заклад;
- **включати** місто/заклад у заголовок і опис тікета (наприклад: «Принтер не друкує — Київ / Заклад Пушкінська»);
- формулювати питання лише про **суть проблеми** (модель принтера, що саме не працює, скріншот помилки тощо).

---

## Два режими створення тікета

| Режим | Умова | Поведінка |
|--------|--------|------------|
| **Без AI** | AI вимкнено в налаштуваннях або немає API-ключа | Класичний сценарій: крок 1 — заголовок, крок 2 — опис, фото, пріоритет, підтвердження. |
| **З AI** | AI увімкнено (Groq/OpenAI) і ключ налаштований | Користувач пише повідомлення → бот аналізує, при потребі ставить уточнюючі питання → формує тікет і показує для підтвердження. |

Обидва варіанти ведуть до одного й того ж: створення тікета в системі після підтвердження.

**Реалізація в проєкті:** Node.js, бекенд — `node-telegram-bot-api` (не Python/aiogram). Логіка обробки повідомлень — у `backend/services/telegramService.js`.

---

## Загальна картина після впровадження AI (2026)

Єдина логічна схема від першого контакту до оцінки тікета: де інтегрується AI, як відбувається перехід між режимами, як це стосується `telegramService.js` та `routes/tickets.js`.

### 1. Цикл життя користувача в боті (з AI)

```
[Новий користувач] → /start
   ↓
[Реєстрація 9 кроків або Авторизація] → створення/оновлення User + telegramId/chatId
   ↓
Головне меню (dashboard)
   ├── Створити тікет ───────────────┐
   ├── Мої тікети / Історія / Статистика
   └── (адмін) Ліміт Groq API

При натисканні «Створити тікет» (callback create_ticket)
   ↓
Перевіряємо AISettings (БД) → AI увімкнено + ключ є?
   ├── Так → Запускаємо AI-режим за замовчуванням (рекомендований шлях)
   └── Ні  → Запускаємо класичний покроковий флоу (як зараз)
```

### 2. AI-режим за замовчуванням (основний шлях)

```
mode = "ai"
ai_attempts = 0
ai_questions_count = 0
dialog_history = []
userContext = { userCity, userPosition, userInstitution, userName?, userEmail? }  // з User профілю

Бот: «Опишіть проблему своїми словами. Наприклад: "Принтер не друкує", "iiko не відкривається".»
     + typing indicator + приклади

Користувач пише повідомлення (text або voice → транскрипт, якщо додаси)
   ↓
handleMessageInSession(chatId, msg)
   ├── Якщо mode !== "ai" → ігнор або перенаправлення
   └── mode === "ai" → додаємо до dialog_history (user + bot)

       Виклик 1: INTENT_ANALYSIS (GPT-4o mini, json_object, max_tokens ~350)
         Вхід: dialog_history + userContext
         Вихід: { isTicketIntent, needsMoreInfo, category?, missingInfo[], confidence }

         Логіка:
         ├── !isTicketIntent → коротка відповідь ("Це не схоже на проблему...") + вихід з сесії або меню
         ├── needsMoreInfo === false && confidence >= 0.7 → перехід до підсумку (виклик 3)
         └── needsMoreInfo === true →
               ai_questions_count++
               Виклик 2: NEXT_QUESTION (max_tokens 100)
                 Вхід: dialog_history + missingInfo + userContext
                 Вихід: одне коротке питання українською

               Відправляємо питання + inline-кнопки:
                 [ Продовжити ]   [ Заповнити по-старому ]   [ Скасувати ]

               Також під кожним питанням: [ По-старому ] [ Скасувати ]

Після кожного аналізу:
   Якщо confidence < 0.5–0.6 → ai_attempts++
   Якщо ai_attempts >= 2 || ai_questions_count >= 3–4 (конфіг):
      mode = "choosing"
      Відправляємо fallback-повідомлення:

      «Я вже {ai_questions_count} раз(и) уточнював і все ще не до кінця зрозумів.
      Давай так:

      [ Продовжити зі мною (AI) ]
      [ Заповнити покроково (класика) ]
      [ Скасувати заявку ]»

Обробка callback з choosing:
   ├── Продовжити зі мною → mode = "ai" (опціонально ai_attempts = 0 або -1)
   ├── Заповнити покроково → mode = "classic", step = "title", ticket_data = {}, dialog_history очищаємо
   └── Скасувати → очищення сесії, dashboard
```

### 3. Класичний режим (fallback або коли AI вимкнено)

```
mode = "classic"
step = "title" / "description" / "photo" / "priority" / "confirm"

Повністю використовує існуючий код:
   handleTicketCreationStep(msg) → збереження в ticket_data
   handleTicketPhoto / handleTicketDocument → збереження файлів
   handlePriorityCallback → ticket_data.priority
   handleFinishTicketCallback → completeTicketCreation(...)

Додатково (опціонально):
   Під кожним кроком кнопка [ Повернутися до розумного режиму ] → mode = "ai", перезапуск AI-флоу
```

### 4. Підтвердження та створення тікета (спільне для обох режимів)

```
У AI-режимі: після виклику 3 (TICKET_SUMMARY) → показуємо готовий тікет + кнопки
   [ Так, створити ]   [ Щось змінити ]   [ Скасувати ]

У класичному: після priority → те саме підтвердження

При "Так, створити":
   completeTicketCreation(chatId, user, session)
     ├── Збирає title, description, category, priority, photos/documents, city з userContext
     ├── Створює Ticket у MongoDB (status: 'open', metadata.source: 'telegram' або 'telegram_ai')
     ├── WebSocket + FCM + група Telegram (як зараз)
     ├── Користувачу: «Тікет ID … створено!» + [Головне меню] + [Дописати в тікет] (deep link)
     └── userSessions.delete(chatId) або reset сесії
```

### 5. Після створення → обробка та оцінка (без змін)

```
Адмін у вебі змінює статус (PUT /api/tickets/:id)
   ↓
sendTicketNotification(ticket, 'updated') → сповіщення користувачу в Telegram

При resolved / closed (якщо !qualityRating.ratingRequested):
   sendQualityRatingRequest(ticket)
     → повідомлення з inline 1–5 + [Головне меню]

Користувач тисне оцінку → rate_ticket_${id}_${rating}
   → handleRateTicketCallback → збереження в ticket.qualityRating
   → «Дякуємо за оцінку!»
```

### 6. Технічна реалізація (node-telegram-bot-api)

- **Сесії:** `userSessions` — Map&lt;chatId, SessionObject&gt; (як зараз).
  - Для масштабування (багато інстансів) — Redis: ключ `session:${chatId}`, поля: `mode`, `step`, `ai_attempts`, `ai_questions_count`, `dialog_history`, `userContext`, `ticket_data`.
- **Обробник повідомлень** (`on('message')`): за наявності сесії — якщо `mode === 'ai'` → додати в історію, виклик AI, логіка аналізу/fallback; якщо `mode === 'classic'` → існуюча `handleTicketCreationStep` тощо; якщо `mode === 'choosing'` → ігнор тексту, чекаємо тільки callback.
- **Callback_query** — обробка всіх кнопок (AI / класика / підтвердження / оцінка).
- **Промпти** — `backend/prompts/aiFirstLinePrompts.js`.
- **Помилки AI** — try/catch навколо виклику OpenAI/Groq → fallback-повідомлення + збереження сесії.
- **Логування** — winston + збереження fallback-статистики в БД для тюнінгу порогів (3 чи 4 питання).

**Результат:** 70–80% тікетів — швидко через AI, 20–30% — fallback без фрустрації; backend (створення тікета, сповіщення, оцінка) спільний.

---

## Повний цикл у боті (поточна реалізація, без AI)

Нижче — аналіз **поточного** потоку від першого контакту з ботом до оцінки виконаного тікета. Це те, як зараз працює бот **без** AI першої лінії.

### 1. Вхід у бота: /start

- Користувач надсилає `/start`.
- Бот шукає користувача в БД за `telegramId`, `telegramChatId` або `telegramUsername`; при знаходженні оновлює `telegramId`/`telegramChatId`.
- **Якщо користувач знайдений і активний** → `showUserDashboard(chatId, user)` (головне меню).
- **Якщо не знайдений** → повідомлення з кнопками: **[Авторизуватися]** **[Зареєструватися]**.

### 2. Реєстрація (callback `register_user`)

- `handleUserRegistrationCallback` → створюється запис у `PendingRegistration`, запускається `processRegistrationStep`.
- Кроки реєстрації (покроково, текст/кнопки):
  1. **firstName** — ім'я  
  2. **lastName** — прізвище  
  3. **email** — email  
  4. **login** — логін  
  5. **phone** — телефон (або «Поділитися номером»)  
  6. **password** — пароль  
  7. **city** — вибір міста зі списку (`city_${id}`)  
  8. **position** — вибір посади (`position_${id}`)  
  9. **institution** — вибір закладу або «Пропустити» (`institution_${id}` / `skip_institution`)  
  10. **completed** → `completeRegistration`: створюється користувач (User), видаляється PendingRegistration, відправляється посилання для підтвердження, потім `showUserDashboard`.

### 3. Авторизація (callback `login_user`)

- Запускається логін: сесія `type: 'login'`, бот просить email.
- Користувач вводить email → бот просить пароль.
- Після успішної перевірки — оновлення `telegramId`/`telegramChatId` у User, `showUserDashboard`.

### 4. Головне меню (dashboard)

- Текст: вітання, профіль (ПІБ, email, посада, місто).
- Кнопки:
  - **Створити тікет** | **Мої тікети**
  - **Історія тікетів** | **Статистика**
  - (для адміна) **Ліміт Groq API**

Інші команди: `/menu` — повернутися в меню, `/help` — довідка, `/status` — швидкий статус відкритих/у роботі тікетів.

### 5. Створення тікета без AI (класичний флоу)

- Користувач натискає **Створити тікет** (`create_ticket`) → `handleCreateTicketCallback`.
- Створюється сесія: `step: 'title'`, `ticketData: { createdBy, photos: [], documents: [] }`.
- **Крок 1 — заголовок:** бот: «Крок 1/4: Введіть заголовок тікету». Користувач надсилає текст → `handleTicketCreationStep`: зберігається `ticketData.title`, `step = 'description'`.
- **Крок 2 — опис:** бот: «Крок 2/4: Введіть опис проблеми». Текст → `ticketData.description`, `step = 'photo'`.
- **Крок 3 — фото/файли:** бот: «Крок 3/4: Бажаєте додати фото або файли?» Кнопки: [Додати фото] [Додати файл] [Пропустити] [Скасувати].
  - Додати фото/файл → `handleTicketPhoto` / `handleTicketDocument` (файл зберігається на сервері, додається в `ticketData.photos`/`documents`). Потім кнопки [Додати ще] [Завершити] [Скасувати].
  - Пропустити або Завершити → `handleFinishTicketCallback`: `step = 'priority'`.
- **Крок 4 — пріоритет:** бот показує кнопки пріоритету (high, medium, low) + [Скасувати]. Callback `priority_${value}` → `handlePriorityCallback`: зберігається `ticketData.priority`, викликається `completeTicketCreation(chatId, user, session)`.

**Скасування:** `cancel_ticket` → `handleCancelTicketCallback`: сесія видаляється, показується головне меню.

### 6. Фіналізація створення тікета

- `completeTicketCreation`:
  - Збирає з сесії: title, description, priority, createdBy, city (з user), photos, documents.
  - Створює документ `Ticket` у MongoDB (`status: 'open'`, `metadata.source: 'telegram'`).
  - Відправляє WebSocket-сповіщення про новий тікет, FCM адмінам, повідомлення в Telegram-групу (якщо налаштовано).
  - Видаляє сесію `userSessions.delete(chatId)`.
  - Користувачу в Telegram: «Тікет успішно створено! ID … Очікуйте відповідь адміністратора» + [Головне меню].

Далі тікет обробляється в веб-інтерфейсі (призначення, коментарі, зміна статусу).

### 7. Мої тікети та перегляд

- **Мої тікети** (`my_tickets`): список останніх 10 тікетів користувача, для кожного — [Деталі] (`view_ticket_${id}`).
- **Деталі тікета** (`handleViewTicketCallback`): заголовок, опис, статус, пріоритет, дата; кнопки [Повторити] (створити новий з тим же заголовком), [Відповісти] (зараз вимкнено — бот пропонує веб-панель).
- **Історія тікетів** (`ticket_history`): закриті/вирішені тікети.
- **Статистика** (`statistics`): кількість тікетів (всього, відкриті, у роботі, закриті), за останній місяць, середній час закриття.

### 8. Зміна статусу тікета та сповіщення користувачу

- Адмін у веб-інтерфейсі змінює статус тікета (наприклад, на «У роботі», «Вирішено», «Закрито»).
- При оновленні тікета (`PUT /api/tickets/:id`) викликається `telegramService.sendTicketNotification(ticket, 'updated')`: користувачу в Telegram приходить повідомлення про зміну статусу (якщо є `telegramId`/`telegramChatId`).

### 9. Запит на оцінку після закриття тікета

- Коли статус тікета змінюється на **resolved** або **closed** (раніше був не закритий), у обробнику оновлення тікета (`backend/routes/tickets.js`) перевіряється: чи вже надсилався запит на оцінку (`qualityRating.ratingRequested`).
- Якщо ні → викликається `telegramService.sendQualityRatingRequest(ticket)`.
  - Для тікетів з `metadata.source === 'telegram'`: користувачу в Telegram відправляється повідомлення «Оцініть якість вирішення» з inline-кнопками оцінки 1–5 (callback `rate_ticket_${ticketId}_${rating}`) та [Головне меню].
  - Для веб/мобільних тікетів — WebSocket/FCM (а при відсутності — fallback у Telegram, якщо є telegramId).
- Після відправки в БД зберігається `qualityRating.ratingRequested = true`, `ratingRequestedAt`.

### 10. Оцінка тікета користувачем

- Користувач натискає кнопку оцінки (1–5) → callback `rate_ticket_${ticketId}_${rating}` → `handleRateTicketCallback`.
- Перевірка: тікет існує, автор тікета = поточний користувач.
- У тікет записується: `qualityRating.hasRating = true`, `rating` (1–5), `ratedAt`, `ratedBy`.
- Користувачу: «Дякуємо за оцінку!».

---

Підсумок поточного циклу: **реєстрація/авторизація → головне меню → створення тікета (заголовок → опис → фото/файли → пріоритет) → збереження тікета в БД та сповіщення → обробка в вебі → при закритті — сповіщення про статус і запит на оцінку → користувач ставить оцінку 1–5.** Вся логіка без AI реалізована в `telegramService.js`; створення тікета — `completeTicketCreation`; запит на оцінку викликається з `routes/tickets.js` при переході в resolved/closed.

---

## AI за замовчуванням + fallback на класику

Рекомендований патерн: **AI-режим за замовчуванням**, плавний **fallback на класичний покроковий режим** після 2–4 невдалих спроб або 3–4 уточнень. Це типовий підхід у Telegram-helpdesk-ботах 2025–2026 (graceful fallback у чатботах).

### Структура стану сесії (на chatId)

Зберігати в сесії (in-memory Map у `telegramService.js`, або Redis/БД при масштабуванні):

| Поле | Тип | Опис |
|------|-----|------|
| `mode` | `"ai"` \| `"classic"` \| `"choosing"` | Поточний режим; `choosing` — тимчасовий стан вибору після пропозиції fallback. |
| `ai_attempts` | number | Лічильник невдалих аналізів або низького confidence. |
| `ai_questions_count` | number | Скільки уточнюючих питань вже поставлено. |
| `dialog_history` | array | Історія повідомлень для AI (користувач + бот). |
| `userContext` | object | Місто, посада, заклад з профілю користувача. |
| `ticket_data` | object | Тимчасові title/description/category/priority під час класичного режиму. |
| `step` | string | Крок у поточному режимі (наприклад `gathering_information`, `title`, `description`, `confirm_ticket`). |

### Потік: AI first → fallback → класика

```
Користувач натискає «Створити тікет»
  ↓
Бот запускає AI-режим за замовчуванням:
  → mode = "ai"
  → ai_attempts = 0, ai_questions_count = 0
  → надсилає: «Опишіть проблему своїми словами. Я постараюся швидко зібрати все необхідне.» (+ приклади, typing indicator)

Користувач пише перше повідомлення
  ↓
Виклик 1 (аналіз наміру)
  • isTicketIntent = false → коротка відповідь + вихід з режиму
  • needsMoreInfo = true →
      → ai_questions_count += 1
      → виклик 2 (генерація питання)
      → відправляє питання + кнопки: [ Продовжити ] [ Заповнити по-старому ] [ Скасувати ]
  • needsMoreInfo = false → перехід до підсумку (виклик 3)

Після кожного нового повідомлення (в AI-режимі):
  ↓
  Виклик 1 по повній історії + userContext
  • confidence < 0.5–0.6 → ai_attempts += 1; можна одразу запропонувати класику (авто-fallback)
  • Якщо ai_attempts ≥ 2 АБО ai_questions_count ≥ 3–4:
      → mode = "choosing"
      → бот надсилає:

        «Я вже {ai_questions_count} раз(и) уточнював і все ще не до кінця зрозумів. Давай так:

        [ Продовжити зі мною (AI) ]
        [ Заповнити покроково (класика) ]
        [ Скасувати заявку ]»

Обробка кнопок (mode = "choosing"):
  • «Продовжити зі мною» → mode = "ai" (ai_attempts можна скинути або залишити)
  • «Заповнити покроково» → mode = "classic", очистити dialog_history, перехід до кроку title (класичний флоу)
  • «Скасувати» → очистити сесію, повернення в головне меню

У mode = "classic":
  → покроково: заголовок → опис → фото → пріоритет → підтвердження
  → опційно під кожним кроком кнопка «Повернутися до розумного режиму»

Після створення тікета (в будь-якому режимі):
  → повне очищення сесії
  → сповіщення + номер тікета + кнопка «Дописати в тікет»
```

### Чому 3–4 уточнення — оптимально

- **Менше 3** — занадто швидко пропонуємо класику, користувач може подумати, що AI слабкий.
- **Більше 4** — фрустрація росте; більшість support-ботів 2025+ обмежують саме 3–4 питаннями перед fallback.

Пороги можна змінити в конфігу (наприклад, 2 невдалі спроби або 4 питання) і підлаштувати після логів.

### Додаткові покращення UX

- **Кнопка під кожним питанням AI**  
  Після кожного уточнюючого питання — inline-кнопки: `[ Заповнити по-старому ]`, `[ Скасувати ]` — щоб можна було вийти з AI-діалогу без очікування 3–4 ітерацій.

- **Прогрес**  
  Після 2-го питання: «Ми вже зібрали ≈ 60% інформації. Ще одне уточнення — і готово!»

- **Авто-fallback при низькому confidence**  
  Якщо після аналізу `confidence < 0.5` — одразу пропонувати перехід на класику (навіть після першого повідомлення).

- **Таймаут без відповіді**  
  Якщо користувач не відповідає 5–7 хвилин — нагадування: «Ви ще тут? Якщо важко описати — можемо заповнити по пунктах» + кнопка [ Перейти в класичний режим ].

- **Логування**  
  Зберігати: кількість fallback-ів, на якому кроці, значення confidence. Через 1–2 тижні можна знизити або підняти поріг (наприклад, з 3 питань на 2).

---

## Сценарій «З AI» (покроково)

### 1. Користувач натискає «Створити тікет»

- Бот відправляє одне повідомлення на кшталт:  
  *«Опишіть проблему своїми словами. Наприклад: "Принтер не друкує", "Не працює телефон у закладі на Пушкінській", "iiko не відкривається".»*
- Стартує сесія збору інформації з AI (крок `gathering_information`, з прапорцем `aiEnabled`).

### 2. Користувач пише перше повідомлення

**Приклад:** «Принтер не друкує.»

- Бот відправляє в **AI (виклик 1 — аналіз наміру)**:
  - **Вхід:** текст користувача, історія діалогу (якщо є), **контекст користувача** (місто, посада, заклад) — щоб AI не питав про них і враховував у категорії/підсумку.
  - Вихід (наприклад, JSON):  
    `isTicketIntent`, `needsMoreInfo`, `category`, `missingInfo[]`, можливо `confidence`.
  - У `missingInfo` лишаються тільки речі, яких **реально немає** (наприклад: модель принтера, що саме не працює), а не місто чи посада.

**Рішення:**

- Якщо **не тікет** (наприклад, питання «як змінити пароль») → бот відповідає коротко і може запропонувати меню або посилання на інструкцію, без створення тікета.
- Якщо **тікет, але бракує даних** (`needsMoreInfo === true`, є `missingInfo`) → **виклик 2** (генерація питання).
- Якщо **достатньо інформації** → **виклик 3** (підсумок тікета).

### 3. Генерація одного уточнюючого питання (виклик 2)

- Вхід: історія діалогу (користувач + бот), `missingInfo` з кроку 1, **контекст користувача** (місто, посада, заклад). AI не генерує питань про місто/посаду/заклад — вони вже відомі.
- AI повертає **одне коротке питання** українською, без технічного жаргону, лише про суть проблеми.  
  Наприклад: *«Яка модель принтера (HP, Canon, Epson)?»* або *«Що саме не працює — зовсім не друкує, погана якість, застрягає папір?»*
- Бот відправляє це питання користувачу і знову чекає текстову відповідь.

### 4. Наступні повідомлення користувача

- Кожна нова репліка додається в історію діалогу.
- Знову виклик 1 (аналіз наміру) по **повному діалогу** (або по останнім N повідомленнях).
- Логіка та сама: не тікет → відповідь і вихід; бракує даних → виклик 2 → одне питання; достатньо → виклик 3.

Так повторюється, поки AI не визначить, що інформації достатньо.

### 5. Формування тікета (виклик 3)

- Вхід: повна історія діалогу (всі репліки користувача) **і контекст користувача** (місто, посада, заклад). AI підставляє місто та заклад у заголовок/опис (наприклад: «Принтер HP не друкує — Київ / Заклад Пушкінська»), оскільки бот їх уже знає.
- AI повертає (наприклад, JSON):  
  `title`, `description`, `category`, `priority`.
- Бот формує повідомлення типу:  
  *«Перевірте, чи все правильно. Заголовок: … Опис: … Категорія: … Пріоритет: …»*  
  і кнопки: **[Так, створити тікет]** / **[Щось змінити]** / **[Скасувати]**.

### 6. Підтвердження та створення

- **Так, створити** → створення тікета в API з `title`, `description`, `category`, `priority`, прикріплення (якщо вже збирались у сесії), далі — стандартне сповіщення та меню.
- **Щось змінити** → можна повернутися до введення тексту (наприклад, «напишіть, що змінити») і ще раз пройти кроки 2–5.
- **Скасувати** → вихід з сесії, очищення стану, повернення в головне меню.

---

## Де саме використовується AI

У **кожен** виклик передається **контекст користувача**: місто, посада, заклад (institution). AI не питає про них і використовує їх у заголовку/описі тікета.

| Етап | Що робить AI | Вхід | Вихід |
|------|----------------|------|--------|
| 1 | Аналіз наміру та достатності інформації | Текст/діалог + **контекст користувача** (місто, посада, заклад) | JSON: тікет чи ні, чи достатньо даних, категорія, що бракує (без міста/посади/закладу) |
| 2 | Генерація одного питання | Діалог + що бракує + **контекст користувача** | Один текст питання українською (лише про проблему, не про місто/посаду) |
| 3 | Підсумок тікета | Повний діалог + **контекст користувача** | JSON: заголовок (з містом/закладом), опис, категорія, пріоритет |

Промпти для цих трьох викликів зберігаються в **`backend/prompts/aiFirstLinePrompts.js`**: `INTENT_ANALYSIS`, `NEXT_QUESTION`, `TICKET_SUMMARY`. Плейсхолдери `{userContext}`, `{dialogHistory}` підставляються при виклику через `fillPrompt()`. Файл `ai-prompts-full.txt` не використовується.

**Рекомендації для API (GPT-4o mini):**
- Виклики 1 і 3: `response_format: { type: "json_object" }` (або structured outputs з json_schema, якщо API підтримує) — для стабільного JSON без зайвого тексту.
- `max_tokens`: виклик 1 — ~350, виклик 2 — 100, виклик 3 — 600–800. Значення експортовані в `aiFirstLinePrompts.js` як `MAX_TOKENS`.

---

## Технічні моменти

- **Контекст користувача в сесії:** при старті діалогу (натиск «Створити тікет») бот зберігає в сесії `userContext`: місто, посада, заклад (institution) з профілю користувача. Цей об’єкт передається в усі три виклики AI, щоб не питати про ці дані і підставляти їх у тікет.
- **Сесія:** одна сесія на `chatId`. Поля: `mode` (`ai` | `classic` | `choosing`), `step`, `userContext`, `dialog_history`, `ai_attempts`, `ai_questions_count`, `ticket_data`, за бажанням `aiDialogId` для логів. При «Скасувати» або після створення тікета сесія повністю очищається.
- **Налаштування AI:** з БД (AISettings): увімкнено/вимкнено, провайдер (Groq/OpenAI), модель, API-ключ. Якщо AI вимкнено або ключа немає — використовується лише класичний покроковий сценарій без викликів AI.
- **Помилки API (Groq/OpenAI):** таймаут або 5xx → повідомлення користувачу «Зараз не можу обробити. Спробуйте ще раз або створіть тікет через меню» і не втрачати сесію (можна дати повторити останнє повідомлення).
- **Фото/файли:** можна приймати під час діалогу (наприклад, «прикріпіть скріншот помилки»), зберігати в сесії і при підтвердженні тікета передавати їх у створення тікета разом з `title`/`description`.

---

## Підсумок: фінальна картина

**Весь цикл у боті (від першого контакту до оцінки):**

1. **Вхід** — `/start` → якщо користувача немає: реєстрація (9 кроків) або авторизація (email + пароль).
2. **Головне меню** — профіль (ПІБ, email, посада, місто), кнопки: Створити тікет, Мої тікети, Історія, Статистика.
3. **Створення тікета:**
   - **Без AI (поточний класичний режим):** заголовок → опис → фото/файли → пріоритет → збереження тікета в БД, сповіщення, повернення в меню.
   - **З AI (майбутній режим):** AI за замовчуванням → вільний опис → діалог (до 3–4 уточнень) → підсумок тікета → підтвердження → той самий крок збереження (completeTicketCreation). При fallback (2–4 невдалі спроби або 3–4 питання) — перехід у класичний флоу (заголовок → опис → фото → пріоритет).
4. **Після створення** — тікет обробляється в веб-інтерфейсі; користувач отримує сповіщення про зміну статусу (sendTicketNotification).
5. **При закритті тікета** (resolved/closed) — користувачу відправляється запит на оцінку (sendQualityRatingRequest); він обирає 1–5 зір → зберігається в `ticket.qualityRating`.

**Де що реалізовано:**

- Реєстрація, авторизація, меню, створення тікета (класика), мої тікети, історія, статистика, оцінка — `backend/services/telegramService.js`.
- Збереження тікета в БД — `completeTicketCreation` у telegramService; оновлення статусу та виклик запиту на оцінку — `backend/routes/tickets.js` (PUT тікета).
- Промпти для AI — `backend/prompts/aiFirstLinePrompts.js`; файл `ai-prompts-full.txt` не використовується.

**Що додано (AI-реалізація):**

- **Залежності:** `groq-sdk`, `openai` у `backend/package.json`.
- **AI-сервіс:** `backend/services/aiFirstLineService.js` — `getAISettings`, `analyzeIntent`, `generateNextQuestion`, `getTicketSummary`; використовує AISettings з БД (provider, apiKey, model).
- **handleCreateTicketCallback:** перевірка AISettings; якщо AI увімкнено і є API-ключ — старт AI-режиму (`mode: 'ai'`, `step: 'gathering_information'`, `userContext`, `dialog_history`, `ai_attempts`, `ai_questions_count`); інакше — класичний флоу (`mode: 'classic'`, `step: 'title'`).
- **handleTextMessage:** якщо `session.mode === 'ai'` — виклик `handleMessageInAiMode`; якщо `session.mode === 'choosing'` — підказка «Оберіть дію кнопками».
- **handleMessageInAiMode:** додає повідомлення в `dialog_history`, викликає `analyzeIntent` → при достатніх даних `getTicketSummary`, зберігає в `session.ticketDraft`, показує резюме з кнопками «Так, створити», «Щось змінити», «Скасувати»; при потребі — `generateNextQuestion`; при порогах (ai_attempts ≥ 2 або ai_questions_count ≥ 4) — перехід у `mode: 'choosing'` з кнопками «Продовжити зі мною (AI)», «Заповнити покроково», «Скасувати заявку».
- **Callback-обробники:** `ai_continue` — повертає `mode = 'ai'`; `ai_switch_to_classic` — переводить у класичний режим (`step: 'title'`, очищення `dialog_history`); `edit_ticket_info` в AI-режимі скидає `ticketDraft` і повертає до збору інформації.
- **confirm_create_ticket:** при `session.step === 'confirm_ticket'` і `session.ticketDraft` копіює draft у `session.ticketData` (включно з `documents: []`) і переводить на крок фото; далі — той самий флоу, що й для класики (attach_photo / skip_photo → completeTicketCreation).
- **completeTicketCreation:** для тікетів, створених через AI, встановлює `metadata.source: 'telegram_ai'` (замість `'telegram'`).
